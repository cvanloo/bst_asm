main:
        push    rbp
        mov     rbp, rsp
        sub     rsp, 80
        mov     dword ptr [rbp - 4], 0
        mov     edi, 32768
        call    arena_make(unsigned long)@PLT
        mov     qword ptr [rbp - 16], rax
        mov     rdi, qword ptr [rbp - 16]
        call    bst_make(Arena*)@PLT
        mov     qword ptr [rbp - 24], rax

;; typedef struct Entries1 Entries1;
;; struct Entries1 {
;;     U64 size;
;;     Entry** entries;
;; };
;; 
;; extern Entries1 bst_find_all1(BST *, Arena *, U64 key);

        mov     rdi, qword ptr [rbp - 24]          ;; BST*
        mov     rsi, qword ptr [rbp - 16]          ;; Arena*
        mov     edx, 7                             ;; key (edx is lower half of rdx)
        call    bst_find_all1(BST*, Arena*, unsigned long)@PLT
        mov     qword ptr [rbp - 40], rax          ;; Entries::size
        mov     qword ptr [rbp - 32], rdx          ;; Entries::entries
        mov     qword ptr [rbp - 48], 0
.LBB0_1:
        mov     rax, qword ptr [rbp - 48]
        cmp     rax, qword ptr [rbp - 40]
        jae     .LBB0_4
        mov     rax, qword ptr [rbp - 32]
        mov     rcx, qword ptr [rbp - 48]
        mov     rax, qword ptr [rax + 8*rcx]
        mov     qword ptr [rbp - 56], rax
        mov     rax, qword ptr [rbp - 56]
        mov     rsi, qword ptr [rax + 8]
        lea     rdi, [rip + .L.str]
        mov     al, 0
        call    printf@PLT
        mov     rax, qword ptr [rbp - 48]
        add     rax, 1
        mov     qword ptr [rbp - 48], rax
        jmp     .LBB0_1
.LBB0_4:

;; typedef struct Entries2 Entries2;
;; struct Entries2 {
;;     U64 size;
;;     Entry* entries[];
;; };
;; 
;; extern Entries2 bst_find_all2(BST *, Arena *, U64 key);

        mov     rsi, qword ptr [rbp - 24]          ;; BST* (here in second argument position)
        mov     rdx, qword ptr [rbp - 16]          ;; Arena* (here in third argument position)
        lea     rdi, [rbp - 64]                    ;; FIRST ARGUMENT: pointer to where we want the RETURN value to be stored!!!!
        mov     ecx, 7                             ;; key (here in fourth argument position, ecx is lower half of rcx)
        call    bst_find_all2(BST*, Arena*, unsigned long)@PLT
        mov     qword ptr [rbp - 72], 0            ;; NOTE: taken from: https://refspecs.linuxfoundation.org/elf/x86_64-abi-0.99.pdf#page=23
                                                   ;; If the type has class MEMORY, then the caller provides space for the return
                                                   ;; value and passes the address of this storage in %rdi as if it were the first
                                                   ;; argument to the function. In effect, this address becomes a “hidden” first ar-
                                                   ;; gument.

;; REASONING:
;; Entry**: the size of the struct is known at compile time: 8B for .size + 8B for .entries
;; Entry*[]: flexible array member: the array is part of the struct's memory layout, i.e., contributes to the struct's size,
;;           although this size is only known at runtime

.LBB0_5:
        mov     rax, qword ptr [rbp - 72]
        cmp     rax, qword ptr [rbp - 64]
        jae     .LBB0_8
        mov     rax, qword ptr [rbp - 72]
        mov     rax, qword ptr [rbp + 8*rax - 56]
        mov     qword ptr [rbp - 80], rax
        mov     rax, qword ptr [rbp - 80]
        mov     rsi, qword ptr [rax + 8]
        lea     rdi, [rip + .L.str]
        mov     al, 0
        call    printf@PLT
        mov     rax, qword ptr [rbp - 72]
        add     rax, 1
        mov     qword ptr [rbp - 72], rax
        jmp     .LBB0_5
.LBB0_8:
        mov     eax, dword ptr [rbp - 4]
        add     rsp, 80
        pop     rbp
        ret

.L.str:
        .asciz  "%s"
